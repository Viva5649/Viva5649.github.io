<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>数据结构与算法（持续更新） | Viva&#39;s Blog</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Viva's Blog">
    <meta name="author" content="Viva">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="Viva&#39;s Blog" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            
        	<li>
        		<a class="sb-toggle-submenu">Categories<span class="sb-caret"></span></a>
            	<ul class="sb-submenu">
				  	
				    <li><a href="/categories/Life/" class="animsition-link">Life<small>(4)</small></a></li>
				    
				    <li><a href="/categories/Tech/" class="animsition-link">Tech<small>(3)</small></a></li>
				    
				</ul>
        	</li>
			
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo_new.jpg" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">Viva's Blog</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            
                            
                            
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2020-09-14T16:00:00.000Z" itemprop="datePublished">
          2020-09-15
      </time>
    
</span>
                <h1>数据结构与算法（持续更新）</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><h2 id="1、时间复杂度"><a href="#1、时间复杂度" class="headerlink" title="1、时间复杂度"></a>1、时间复杂度</h2><p><strong>1.1</strong> 概念<br>公式：T(n) = O(f(n))；所有代码的执行时间T(n)与每行代码的执行次数n成正比。<br>反映的是<strong>代码执行时间随着数据规模增长的变化趋势</strong>。</p>
<p><strong>1.2</strong> 分析技巧<br>(1) 只关注循环执行次数最多的一段代码。<br>(2) 加法法则：总复杂度等于量级最大的那段代码的复杂度。<br>(3) 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。</p>
<p><strong>1.3</strong> 常见时间复杂度<br>O(n ^ 2) &gt; O(n * logn) &gt; O(n) &gt; O(logn) &gt; O(1)</p>
<p><strong>1.4</strong> 细分<br>(1) 最好情况时间复杂度：最理想情况下，执行代码的时间复杂度。<br>(2) 最坏情况时间复杂度：最糟糕情况下，执行代码的时间复杂度。<br>(3) 平均情况时间复杂度：根据概率计算得出的加权平均时间复杂度（期望时间复杂度）。<br>(4) 均摊时间复杂度：通过摊还分析方法得到，可以将时间复杂度高的操作，平摊到其他时间复杂度较低的操作上，用于特殊场景（对于一个数据结构的一组连续操作中，大部分情况下时间复杂度很低，个别情况下时间复杂度较高，且操作前后连贯具有一定规律性）。</p>
<h2 id="2、空间复杂度"><a href="#2、空间复杂度" class="headerlink" title="2、空间复杂度"></a>2、空间复杂度</h2><p><strong>2.1</strong> 概念<br>反映的是<strong>算法的存储空间与数据规模之间的增长关系</strong>。</p>
<p><strong>2.2</strong> 常见空间复杂度<br>O(n ^ 2) &gt; O(n) &gt; O(1)</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h3><p><strong>1.1</strong> 概念<br>一种线性表数据结构，使用一组<strong>连续</strong>的内存空间，来存储一组具有相同类型的数据。</p>
<p><strong>1.2</strong> 特点<br>(1) 随机访问<br>根据数组首地址，被访问元素的下标和数据类型的长度，可以<strong>高效</strong>地访问到特定的元素，时间复杂度为O(1)。<br>(2) 插入<br>元素有序：在数组中间插入和删除时可能涉及多个元素的数据搬运。<br>元素无序：插入时将指定位置的已有元素移到数组尾部，再将新元素插入指定位置以提升效率。<br>(3) 删除<br>删除元素时为了保证数组中数据的连续性，不可避免地要进行数据搬运（删除最后一个元素这种情况除外）。可以每次先记录下要删除的数据，在数据没有更多空间时，再进行真正的删除操作，减少大量数据搬运的次数。</p>
<p><strong>1.3</strong> 思考题：数组下标为何从0开始？<br>当下标从0开始时，寻址公式伪代码为<code>a[i]_address = base_address + i * data_type_size;</code><br>当下标从1开始时，寻址公式伪代码为<code>a[i]_address = base_address + (i-1) * data_type_size;</code><br>对比后可以看出，当下标不为0时，每次随机访问，都需要额外做一次减法操作，为了将效率优化到极致，数组采取了下标从0开始的做法。</p>
<h3 id="2、链表"><a href="#2、链表" class="headerlink" title="2、链表"></a>2、链表</h3><p><strong>2.1</strong> 概念<br>一种线性表数据结构，通过“指针”将一组零散的内存块（结点）串联起来使用。</p>
<p><strong>2.2</strong> 特点<br>(1) 随机访问<br>非连续存储，需要依次遍历，时间复杂度为O(n)。<br>(2) 插入和删除<br>只需改变相邻结点的指针，时间复杂度为O(1)。</p>
<p><strong>2.3</strong> 分类<br>(1) 单链表<br>每个结点存储数据，同时记录下一个结点的地址。<br>头结点记录链表的基地址，尾结点指向NULL。<br>(2) 循环链表<br>在单链表的基础上，尾结点指针指向头结点。<br>(3) 双向链表<br>在单链表的基础上，每个结点额外增加一个指针，指向上一个结点。<br>优点在于在特定结点前插入和删除一个特定结点时，无需<strong>从头遍历</strong>来获取特定结点的上一个结点。<br>体现了一种“用空间换时间”的设计思想。<br>(4) 双向循环链表<br>循环链表和双向链表的结合</p>
<p><strong>2.4</strong> 链表代码编写技巧<br>(1) 理解指针和引用的含义<br>将某个变量赋值给指针，实际就是将这个变量的地址赋值给指针，指针中保存了这个变量的内存地址，通过指针就能访问到该变量。<br>(2) 警惕指针丢失和内存泄漏<br>插入结点时注意操作顺序。<br>删除结点时注意内存的释放。<br>(3) 利用“哨兵”简化实现难度<br>使用“哨兵”结点来统一链表插入和删除的实现代码。<br>使用“哨兵”减少对于边界情况的判断。<br>(4) 重点留意边界条件处理<br>(5) 举例画图，辅助思考<br>(6) 多写多练，练习常用链表操作</p>
<p><strong>2.5</strong> 思考题：如何用链表来实现LRU缓存淘汰策略（最近最少使用策略）？<br>(1) 维护一个有序单链表，越靠近链表尾部的结点是越早访问的。<br>(2) 当有一个新的数据被访问时，从链表头部开始顺序遍历链表。<br>(3) 如果数据之前已存在，则将其从原先的位置删除，然后插入链表的头部。<br>(4) 如果数据没有存在链表中，看链表是否已满：若未满，将数据插入链表头部；若已满，则将链表尾结点删除，将数据插入链表头部。</p>
<p><strong>2.6</strong> LeetCode题号<br>单链表反转（206）<br>链表中环的检测（141）<br>两个有序链表的合并（21）<br>删除链表倒数第n个结点（19）<br>获取链表的中间结点（876）</p>
<h3 id="3、栈"><a href="#3、栈" class="headerlink" title="3、栈"></a>3、栈</h3><p><strong>3.1</strong> 概念<br>一种操作受限的线性表数据结构，有后进先出和先进后出的特性。</p>
<p><strong>3.2</strong> 特点<br>(1) 数据集合只涉及一端的插入和删除操作。<br>(2) 后进先出，先进后出。</p>
<p><strong>3.3</strong> 应用场景<br>(1) 函数调用栈<br>每个线程的独立内存空间，会被组织成“栈”结构，用来存储函数调用时的临时变量<br>(2) 表达式求值<br>使用两个栈，一个存储操作数，一个存储运算符。当运算符比栈顶元素优先级高时，运算符入栈；比栈顶元素优先级低或相同时，从运算符栈中取出栈顶运算符，从操作数栈中取出栈顶的两个操作数，进行计算，然后把结果压入操作数栈。<br>(3) 括号匹配<br>扫描字符串，遇到左括号入栈，遇到右括号时与栈顶元素匹配，成功配对后将栈顶元素出栈。若扫描完成后栈为空，则字符串格式合法，否则格式非法。</p>
<p><strong>3.4</strong> 思考题：如何实现浏览器的前进后退功能？<br>使用两个栈。栈A保存每次跳转的页面，跳转到新页面时，压入栈A。后退时，将页面从栈A出栈，压入栈B中。前进时，将页面从栈B出栈，压入栈A中。中途跳转时，要清空栈B中的页面。</p>
<p><strong>3.5</strong> LeetCode题号<br>20、155、232、844、224、682、496</p>
<h3 id="4、队列"><a href="#4、队列" class="headerlink" title="4、队列"></a>4、队列</h3><p><strong>4.1</strong> 概念<br>一种操作受限的线性表数据结构，有先进先出和后进后出的特性。</p>
<p><strong>4.2</strong> 特点<br>(1) 入队时将元素插入队列尾部，出队时从队列头部读取元素。<br>(2) 先进先出，后进后出。</p>
<p><strong>4.3</strong> 分类<br>(1) 循环队列<br>能够避免入队操作时可能触发的数据搬移，若用数组实现，会浪费一个存储空间。<br>队列为空的判断条件：head == tail。<br>队列为满的判断条件：(tail + 1) % n == head。<br>入队时，tail = (tail + 1) % n。<br>出队时，head = (head + 1) % n。<br>(2) 阻塞队列<br>当队列为空时，从队列头部取数据会被阻塞，直到队列中有数据才会取出数据并返回。<br>当队列已满时，在队列尾部插入数据会被阻塞，直到队列中有空闲位置才会插入数据并返回。<br>(3) 并发队列<br>线程安全的队列。<br>基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。</p>
<p><strong>4.4</strong> 思考题：线程池没有空闲线程时，新的任务请求线程资源，线程池该如何处理？<br>策略分为2种<br>(1) 非阻塞：直接拒绝任务请求。<br>(2) 阻塞：使用队列来保存请求，有空闲线程时，再从队列中取出请求继续处理。<br>对于阻塞式的策略，基于数组实现的有边界队列更加合适，当已排队的请求数量达到队列大小时，新来的请求会被拒绝，设置合理的队列大小十分关键。</p>
<h3 id="5、跳表"><a href="#5、跳表" class="headerlink" title="5、跳表"></a>5、跳表</h3><p><strong>5.1</strong> 概念<br>1、在链表的基础上，增加多级索引结构。<br>2、每x个节点中抽出一个结点作为上一级索引的结点，x一般为2，为了节省空间可以使用更大的值。<br>3、在每层索引的基础上继续向上构建索引，直到最顶层索引结点的个数到x为止。</p>
<p><strong>5.2</strong> 特点<br>假设抽取规则中x为2<br>1、第k级索引格式是第k-1级索引的结点个数的1/2，第k级索引结点个数是n/(2^k)。<br>2、假设索引有k层，最高级的索引层有2个结点，则n/(2^k) = 2，每层只需要遍历（x + 1）个结点，其时间复杂度为O(logn)。<br>3、索引占用的空间大小为n/2 + n/4 + … + 4 + 2，需要额外用接近n个结点的存储空间，空间复杂度为O(n)。</p>
<p><strong>5.3</strong> 动态更新  </p>
<p>1、插入时，可以通过一个随机函数，来决定将当前结点插入到哪几级索引中（比如随机函数生成了值k，那就将该结点添加到第1级至第k级这些索引中）。<br>2、删除时，不仅要删除原始链表中的结点，还要删除索引中的结点。</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><strong>满足条件</strong><br>1、一个问题的解可以分解为几个子问题的解。<br>2、主问题和分解之后的子问题，除了数据规模不同，求解思路完全一样。<br>3、存在递归终止条件。</p>
<p><strong>如何编写递归代码</strong><br>1、写出递推公式。<br>2、找到终止条件。<br>3、关键在于找到<strong>如何将大问题分解成小问题的规律</strong>。</p>
<p><strong>思考技巧</strong><br>仅思考主问题和子问题之间的关系，不用关注子问题更下层的调用关系，不要试图用人脑去分解递归的每个步骤。</p>
<p><strong>注意事项</strong><br>1、避免递归深度过大导致堆栈溢出（空间复杂度高）。<br>2、避免重复计算（函数调用耗时多）。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="1、排序算法的分析"><a href="#1、排序算法的分析" class="headerlink" title="1、排序算法的分析"></a>1、排序算法的分析</h3><p><strong>1.1</strong> 基本操作<br>1、元素的比较。<br>2、元素的交换或移动。</p>
<p><strong>1.2</strong> 执行效率<br>1、最好情况、最坏情况、平均情况时间复杂度。<br>2、考虑时间复杂度的系数、常数、低阶。<br>3、元素的比较次数和移动次数。</p>
<p><strong>1.3</strong> 内存消耗<br>原地排序算法：指空间复杂度为O(1)的排序算法。</p>
<p><strong>1.4</strong> 稳定性<br>待排序的序列中存在值相等的元素，经过排序后，如果相等元素之间原有的先后顺序不变，则排序算法称为<strong>稳定排序算法</strong>，否则称为<strong>不稳定排序算法</strong>。</p>
<p><strong>1.5</strong> 额外概念<br>1、有序度：数据中具有有序关系的元素对的个数。<br>2、逆序度：数据中不具有有序关系的元素对的个数。<br>3、满有序度：完全有序的数据的有序度，值为n*(n-1)/2。</p>
<p><strong>1.6</strong> 备注<br>后续涉及的排序算法均以元素为数字的数组为例进行阐述。</p>
<h3 id="2、冒泡排序"><a href="#2、冒泡排序" class="headerlink" title="2、冒泡排序"></a>2、冒泡排序</h3><p><strong>2.1</strong> 核心思想<br>每次只操作相邻的两个数据，若不满足关系，则将相邻元素交换。</p>
<p><strong>2.2</strong> 实现思路<br>使用2个for循环，内部for循环每次执行完后，保证从数组尾部开始的元素是有序的，具体有序的元素的个数随着每次循环会增加。</p>
<p><strong>2.3</strong> 时间复杂度<br>1、最好情况：O(n)；数组中的元素已有序，只需依次做比较操作。<br>2、最坏情况：O(n^2)；数组中的元素为倒序排列，要做n次冒泡操作。<br>3、平均情况：O(n^2)；满有序度 = n*(n-1)/2 = 有序度+逆序度；每交换一次，有序度+1，初始逆序度=总交换次数。</p>
<h3 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h3><p><strong>3.1</strong> 核心思想<br>取“未排序区间”中的元素，在“已排序区间”中找到合适的位置将其插入（涉及数组元素的移动），并保证已排序区间中的元素一直有序，重复该过程，直到未排序区间为空为止。</p>
<p><strong>3.2</strong> 实现思路<br>使用2个for循环，内部for循环执行完之后，保证从数组头部开始的元素是有序的，具体有序的元素的个数随着每次循环会增加。</p>
<p><strong>3.3</strong> 时间复杂度<br>1、最好情况：O(n)；数组中的元素已有序，只需依次做比较操作。<br>2、最坏情况：O(n^2)；数组中的元素为倒序排列，需要大量移动数据。<br>3、平均情况：O(n^2)。</p>
<p><strong>3.4</strong> 思考题：插入排序为何比冒泡排序更受欢迎？<br>1、冒泡排序的元素交换，会引入临时变量，进行3次赋值。<br>2、插入排序的元素移动，只进行1次赋值。</p>
<h3 id="4、选择排序"><a href="#4、选择排序" class="headerlink" title="4、选择排序"></a>4、选择排序</h3><p><strong>4.1</strong> 核心思想<br>类似于插入排序，每次从未排序区间中找到最小的元素，放到已排序区间的末尾（涉及数组元素的交换）。</p>
<p><strong>4.2</strong> 时间复杂度<br>1、最好情况：O(n^2)。<br>2、最坏情况：O(n^2)。<br>3、平均情况：O(n^2)。</p>
<h3 id="5、归并排序"><a href="#5、归并排序" class="headerlink" title="5、归并排序"></a>5、归并排序</h3><p><strong>5.1</strong> 核心思想<br><strong>分治</strong>：将数组从中间分为前后两部分，对前后两部分别进行排序，再将排序好的两部分合并在一起；利用递归技巧，对于拆分后的部分进行再次拆分的操作。</p>
<p><strong>5.2</strong> 时间复杂度（通过递归思想分解时间复杂度的组成部分得出）<br>1、最好情况：O(n <em> logn)。<br>2、最坏情况：O(n </em> logn)。<br>3、平均情况：O(n * logn)。</p>
<p><strong>5.3</strong> 空间复杂度<br>每次合并时临时开辟的空间在使用完之后会被立即释放，临时内存空间最大不会超过n个数据的大小，空间复杂度为O(n)。</p>
<h3 id="6、快速排序"><a href="#6、快速排序" class="headerlink" title="6、快速排序"></a>6、快速排序</h3><p><strong>6.1</strong> 核心思想<br><strong>分治</strong>：选择数组中任意一个元素的位置作为<strong>分区点</strong>，遍历数组，将小于分区点元素的元素放在其左边，将大于分区点元素的元素放在其右边；利用递归技巧对于分区后的数据再次进行分区操作。</p>
<p><strong>6.2</strong> 完成原地分区的技巧<br>使用数组元素的交换来避免递归分区过程中占用很多临时的内存空间，空间复杂度为O(1)。</p>
<p><strong>6.3</strong> 与归并排序的区别<br>1、归并排序：处理过程由下到上，子问题处理完后进行合并，一层一层往上。<br>2、快速排序：处理过程由上到下，先分区再处理子问题。</p>
<p><strong>6.4</strong> 时间复杂度<br>1、最好情况：O(n <em> logn)。<br>2、最坏情况：O(n^2)。<br>3、平均情况：O(n </em> logn)。</p>
<p><strong>6.5</strong> 特点<br>1、通用性好：覆盖场景广泛。<br>2、性能好：时间复杂度相对低；空间复杂度最低。</p>
<p><strong>6.6</strong> 优化技巧<br>1、合理选择分区点：多数取中（取多个分布在区间全范围的值，取中间值）；随机（随机选择一个元素作为分区点）。<br>2、防止栈溢出：设置递归次数阈值；在堆上实现一个函数调用栈，模拟递归操作。</p>
<h3 id="7、桶排序"><a href="#7、桶排序" class="headerlink" title="7、桶排序"></a>7、桶排序</h3><p><strong>7.1</strong> 核心思想<br>将要排序的数据分散到多个桶中，将每个桶里的数据单独进行排序，完成后，再把每个桶中的数据按照顺序取出，就组成了有序的数据。</p>
<p><strong>7.2</strong> 应用场景<br>外部排序：数据存储在外部磁盘中，数据量较大，内存有限，无法将数据全部加载到内存中。</p>
<p><strong>7.3</strong> 时间复杂度<br>O(n)：如果要排序的数据有n个，均匀分到m个桶内，每个桶里有k = n/m个元素。每个桶内使用快速排序，时间复杂度为O(k <em> logk)。m个桶的时间复杂度就是O(m </em> k <em> logk)，就是O(n </em> log(n/m))。当桶的个数接近数据个数n时，log(n/m)就是一个非常小的常量，这时候桶排序的时间复杂度接近O(n)。</p>
<h3 id="8、计数排序"><a href="#8、计数排序" class="headerlink" title="8、计数排序"></a>8、计数排序</h3><p><strong>8.1</strong> 核心思想<br>一种特殊情况下的桶排序。若数据的最大值是k，把数据划分成k个桶，每个桶内的数据值都是相同的，省掉了桶内排序的时间。借助处理过的桶数组（索引对应了数据值，元素为小于等于该索引值的数据的个数），利用元素值来确定当前数据值在排序后数组中的位置（取数据时需要从原始数据的最后一个元素开始往前遍历，以保证稳定性），来给原始数据排序。</p>
<p><strong>8.2</strong> 应用场景<br>要排序的n个数据，<strong>数据范围并不大</strong>的时候；只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>
<p><strong>8.3</strong> 时间复杂度<br>O(n)。</p>
<h3 id="9、基数排序"><a href="#9、基数排序" class="headerlink" title="9、基数排序"></a>9、基数排序</h3><p><strong>9.1</strong> 核心思想<br>处理要排序的数据，位数不够的在后面补“0”。</p>
<p><strong>9.2</strong> 应用场景<br>被排序的数据，可以分割出独立的“位”来比较，位与位之间有递进关系，每一位的数据范围不能太大。</p>
<p><strong>9.3</strong> 时间复杂度<br>O(n)。</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="1、二分查找"><a href="#1、二分查找" class="headerlink" title="1、二分查找"></a>1、二分查找</h3><p><strong>1.1</strong> 核心思想<br>每次通过与区间的中间元素进行对比，将查找范围缩小一半，直到查到指定元素或区间被缩小为0。</p>
<p><strong>1.2</strong> 应用场景<br>1、数据存储在顺序表结构中（数组，能够通过下标进行随机访问）。<br>2、数据必须是有序的。<br>3、数据量适中（太小的话时间上相比顺序遍历没有优势，太大的话对于内存要求过高）。</p>
<p><strong>1.3</strong> 变形问题<br>常用于有序集合（从小到大排列）中存在重复元素的场景。<br>注意细节：终止条件、区间上下边界更新方法、返回值选择。<br>1、查找第一个 值<strong>等于</strong>指定值的元素。<br>思路：查找到给定值的时候，判断当前位置的前一个元素的值是否也为给定值。<br>2、查找最后一个 值<strong>等于</strong>给定值的元素。<br>思路：与查找第一个符合条件的元素相似，查找到指定值的时候，判断当前位置的后一个元素的值是否也为指定值。<br>3、查找第一个 值<strong>大于等于</strong>给定值的元素。<br>思路：每当查找到给定值的位置，判断其前一个元素的值是否小于给定值。<br>4、查找最后一个 值<strong>小于等于</strong>给定值的元素。<br>思路：每当查找到给定值的位置，判断其后一个元素值是否大于给定值。</p>
<p><strong>1.4</strong> 时间复杂度<br>O(logn)。</p>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    <a class="pull-left" href="/2020/09/16/设计模式/" style="float: left;">
        ← 设计模式（持续更新）
    </a>
    
    
    <a class="pull-right" href="/2020/09/03/2020-09-03/">
        Thu Sep 03 2020 00:00:00 GMT+0800 (CST) →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By Viva. All Rights Reserved.
                </p>
                <a href="http://www.beian.miit.gov.cn" style="color: #767D84">浙ICP备20020134号</a>
                <!-- <p>Theme By <a href="//go.kieran.top" style="color: #767D84">Kieran</a></p> -->
            </div>
            <div class="social">
                <ul>
                    
                    
                    
                    
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
