<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>算法 | Viva&#39;s Blog</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Viva's Blog">
    <meta name="author" content="Viva">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="Viva&#39;s Blog" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            
        	<li>
        		<a class="sb-toggle-submenu">Categories<span class="sb-caret"></span></a>
            	<ul class="sb-submenu">
				  	
				    <li><a href="/categories/Tech/" class="animsition-link">Tech<small>(9)</small></a></li>
				    
				</ul>
        	</li>
			
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo_new.jpg" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">Viva's Blog</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            
                            
                            
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2021-01-01T16:00:00.000Z" itemprop="datePublished">
          2021-01-02
      </time>
    
</span>
                <h1>算法</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>公式：T(n) = O(f(n))；所有代码的执行时间T(n)与每行代码的执行次数n成正比。<br>反映的是<strong>代码执行时间随着数据规模增长的变化趋势</strong>。</p>
<h3 id="分析技巧"><a href="#分析技巧" class="headerlink" title="分析技巧"></a>分析技巧</h3><p>(1) 只关注循环执行次数最多的一段代码。<br>(2) 加法法则：总复杂度等于量级最大的那段代码的复杂度。<br>(3) 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。</p>
<h3 id="常见时间复杂度"><a href="#常见时间复杂度" class="headerlink" title="常见时间复杂度"></a>常见时间复杂度</h3><p>O(n!) &gt; O(2^n) &gt; O(n^2) &gt; O(nlogn) &gt; O(n) &gt; O(logn) &gt; O(1)</p>
<h3 id="细分"><a href="#细分" class="headerlink" title="细分"></a>细分</h3><p>(1) 最好情况时间复杂度：最理想情况下，执行代码的时间复杂度。<br>(2) 最坏情况时间复杂度：最糟糕情况下，执行代码的时间复杂度。<br>(3) 平均情况时间复杂度：根据概率计算得出的加权平均时间复杂度（期望时间复杂度）。<br>(4) 均摊时间复杂度：通过摊还分析方法得到，可以将时间复杂度高的操作，平摊到其他时间复杂度较低的操作上，用于特殊场景（对于一个数据结构的一组连续操作中，大部分情况下时间复杂度很低，个别情况下时间复杂度较高，且操作前后连贯具有一定规律性）。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>反映的是<strong>算法的存储空间与数据规模之间的增长关系</strong>。</p>
<h3 id="常见空间复杂度"><a href="#常见空间复杂度" class="headerlink" title="常见空间复杂度"></a>常见空间复杂度</h3><p>O(n^2) &gt; O(n) &gt; O(1)</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="满足条件"><a href="#满足条件" class="headerlink" title="满足条件"></a>满足条件</h3><p>1、一个问题的解可以分解为几个子问题的解。<br>2、主问题和分解之后的子问题，除了数据规模不同，求解思路完全一样。<br>3、存在递归终止条件。</p>
<h3 id="如何编写递归代码"><a href="#如何编写递归代码" class="headerlink" title="如何编写递归代码"></a>如何编写递归代码</h3><p>1、写出递推公式。<br>2、找到终止条件。<br>3、关键在于找到<strong>如何将大问题分解成小问题的规律</strong>。</p>
<h3 id="思考技巧"><a href="#思考技巧" class="headerlink" title="思考技巧"></a>思考技巧</h3><p>仅思考主问题和子问题之间的关系，不用关注子问题更下层的调用关系，不要试图用人脑去分解递归的每个步骤。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1、避免递归深度过大导致堆栈溢出（空间复杂度高）。<br>2、避免重复计算（函数调用耗时多）。</p>
<h3 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h3><p>尾递归：在函数返回的时候，调用函数自身，且return语句不包含表达式。这样，编译器或解释器可以对尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>
<h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Recur(int level, int param) &#123;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (level &gt; MAX_LEVEL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 当前层的处理逻辑</span><br><span class="line">    </span><br><span class="line">    // 进行递归调用</span><br><span class="line">    Recur(level, param);</span><br><span class="line">    </span><br><span class="line">    // 清理当前层状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>后续涉及的排序算法均以元素为数字的数组为例进行阐述。</p>
<h3 id="1、排序算法的分析"><a href="#1、排序算法的分析" class="headerlink" title="1、排序算法的分析"></a>1、排序算法的分析</h3><p><strong>1.1</strong> 基本操作<br>(1) 元素的比较。<br>(2) 元素的交换或移动。</p>
<p><strong>1.2</strong> 执行效率<br>(1) 最好情况、最坏情况、平均情况时间复杂度。<br>(2) 考虑时间复杂度的系数、常数、低阶。<br>(3) 元素的比较次数和移动次数。</p>
<p><strong>1.3</strong> 内存消耗<br>原地排序算法：指空间复杂度为 O(1) 的排序算法。</p>
<p><strong>1.4</strong> 稳定性<br>待排序的序列中存在值相等的元素，经过排序后，如果相等元素之间原有的先后顺序不变，则排序算法称为<strong>稳定排序算法</strong>，否则称为<strong>不稳定排序算法</strong>。</p>
<p><strong>1.5</strong> 额外概念<br>(1) 有序度：数据中具有有序关系的元素对的个数。<br>(2) 逆序度：数据中不具有有序关系的元素对的个数。<br>(3) 满有序度：完全有序的数据的有序度，值为 n*(n-1)/2。</p>
<h3 id="2、冒泡排序"><a href="#2、冒泡排序" class="headerlink" title="2、冒泡排序"></a>2、冒泡排序</h3><p><strong>2.1</strong> 核心思想<br>每次只操作相邻的两个数据，若不满足关系，则将相邻元素交换。</p>
<p><strong>2.2</strong> 实现思路<br>使用 2 个 for 循环，内部 for 循环每次执行完后，保证从数组尾部开始的元素是有序的，具体有序的元素的个数随着每次循环会增加。</p>
<p><strong>2.3</strong> 时间复杂度<br>(1) 最好情况：O(n)；数组中的元素已有序，只需依次做比较操作。<br>(2) 最坏情况：O(n^2)；数组中的元素为倒序排列，要做 n 次冒泡操作。<br>(3) 平均情况：O(n^2)；满有序度 = n*(n-1)/2 = 有序度+逆序度；每交换一次，有序度+1，初始逆序度 = 总交换次数。</p>
<h3 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h3><p><strong>3.1</strong> 核心思想<br>取“未排序区间”中的元素，在“已排序区间”中找到合适的位置将其插入（涉及数组元素的移动），并保证已排序区间中的元素一直有序，重复该过程，直到未排序区间为空为止。</p>
<p><strong>3.2</strong> 实现思路<br>使用 2 个 for 循环，内部 for 循环执行完之后，保证从数组头部开始的元素是有序的，具体有序的元素的个数随着每次循环会增加。</p>
<p><strong>3.3</strong> 时间复杂度<br>(1) 最好情况：O(n)；数组中的元素已有序，只需依次做比较操作。<br>(2) 最坏情况：O(n^2)；数组中的元素为倒序排列，需要大量移动数据。<br>(3) 平均情况：O(n^2)。</p>
<p><strong>3.4</strong> 思考题：插入排序为何比冒泡排序更受欢迎？<br>(1) 冒泡排序的元素交换，会引入临时变量，进行 3 次赋值。<br>(2) 插入排序的元素移动，只进行 1 次赋值。</p>
<h3 id="4、选择排序"><a href="#4、选择排序" class="headerlink" title="4、选择排序"></a>4、选择排序</h3><p><strong>4.1</strong> 核心思想<br>类似于插入排序，每次从未排序区间中找到最小的元素，放到已排序区间的末尾（涉及数组元素的交换）。</p>
<p><strong>4.2</strong> 时间复杂度<br>(1) 最好情况：O(n^2)。<br>(2) 最坏情况：O(n^2)。<br>(3) 平均情况：O(n^2)。</p>
<h3 id="5、归并排序"><a href="#5、归并排序" class="headerlink" title="5、归并排序"></a>5、归并排序</h3><p><strong>5.1</strong> 核心思想<br><strong>分治</strong>：将数组从中间分为前后两部分，对前后两部分别进行排序，再将排序好的两部分合并在一起；利用递归技巧，对于拆分后的部分进行再次拆分的操作。</p>
<p><strong>5.2</strong> 时间复杂度（通过递归思想分解时间复杂度的组成部分得出）<br>(1) 最好情况：O(nlogn)。<br>(2) 最坏情况：O(nlogn)。<br>(3) 平均情况：O(nlogn)。</p>
<p><strong>5.3</strong> 空间复杂度<br>每次合并时临时开辟的空间在使用完之后会被立即释放，临时内存空间最大不会超过 n 个数据的大小，空间复杂度为 O(n)。</p>
<h3 id="6、快速排序"><a href="#6、快速排序" class="headerlink" title="6、快速排序"></a>6、快速排序</h3><p><strong>6.1</strong> 核心思想<br><strong>分治</strong>：选择数组中任意一个元素的位置作为<strong>分区点</strong>，遍历数组，将小于分区点元素的元素放在其左边，将大于分区点元素的元素放在其右边；利用递归技巧对于分区后的数据再次进行分区操作。</p>
<p><strong>6.2</strong> 完成原地分区的技巧<br>使用数组元素的交换来避免递归分区过程中占用很多临时的内存空间，空间复杂度为 O(1)。</p>
<p><strong>6.3</strong> 与归并排序的区别<br>(1) 归并排序：处理过程由下到上，子问题处理完后进行合并，一层一层往上。<br>(2) 快速排序：处理过程由上到下，先分区再处理子问题。</p>
<p><strong>6.4</strong> 时间复杂度<br>(1) 最好情况：O(nlogn)。<br>(2) 最坏情况：O(n^2)。<br>(3) 平均情况：O(nlogn)。</p>
<p><strong>6.5</strong> 特点<br>(1) 通用性好：覆盖场景广泛。<br>(2) 性能好：时间复杂度相对低；空间复杂度最低。</p>
<p><strong>6.6</strong> 优化技巧<br>(1) 合理选择分区点：多数取中（取多个分布在区间全范围的值，取中间值）；随机（随机选择一个元素作为分区点）。<br>(2) 防止栈溢出：设置递归次数阈值；在堆上实现一个函数调用栈，模拟递归操作。</p>
<h3 id="7、桶排序"><a href="#7、桶排序" class="headerlink" title="7、桶排序"></a>7、桶排序</h3><p><strong>7.1</strong> 核心思想<br>将要排序的数据分散到多个桶中，将每个桶里的数据单独进行排序，完成后，再把每个桶中的数据按照顺序取出，就组成了有序的数据。</p>
<p><strong>7.2</strong> 应用场景<br>外部排序：数据存储在外部磁盘中，数据量较大，内存有限，无法将数据全部加载到内存中。</p>
<p><strong>7.3</strong> 时间复杂度<br>O(n)：如果要排序的数据有 n 个，均匀分到 m 个桶内，每个桶里有 k = n/m 个元素。每个桶内使用快速排序，时间复杂度为 O(k * logk)。m 个桶的时间复杂度就是 O(m * k * logk)，就是 O(n * log(n/m))。当桶的个数接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这时候桶排序的时间复杂度接近 O(n)。</p>
<h3 id="8、计数排序"><a href="#8、计数排序" class="headerlink" title="8、计数排序"></a>8、计数排序</h3><p><strong>8.1</strong> 核心思想<br>一种特殊情况下的桶排序。若数据的最大值是 k，把数据划分成 k 个桶，每个桶内的数据值都是相同的，省掉了桶内排序的时间。借助处理过的桶数组（索引对应了数据值，元素为小于等于该索引值的数据的个数），利用元素值来确定当前数据值在排序后数组中的位置（取数据时需要从原始数据的最后一个元素开始往前遍历，以保证稳定性），来给原始数据排序。</p>
<p><strong>8.2</strong> 应用场景<br>要排序的 n 个数据，<strong>数据范围并不大</strong>的时候；只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>
<p><strong>8.3</strong> 时间复杂度<br>O(n)。</p>
<h3 id="9、基数排序"><a href="#9、基数排序" class="headerlink" title="9、基数排序"></a>9、基数排序</h3><p><strong>9.1</strong> 核心思想<br>处理要排序的数据，位数不够的在后面补“0”。</p>
<p><strong>9.2</strong> 应用场景<br>被排序的数据，可以分割出独立的“位”来比较，位与位之间有递进关系，每一位的数据范围不能太大。</p>
<p><strong>9.3</strong> 时间复杂度<br>O(n)。</p>
<h3 id="10、堆排序"><a href="#10、堆排序" class="headerlink" title="10、堆排序"></a>10、堆排序</h3><p><strong>10.1</strong> 核心思想<br>借助“二叉堆”数据结构实现的排序算法。</p>
<p><strong>10.2</strong> 准备工作（建堆）<br>在数组上，不借助其他数组，原地建堆。<br>(1) 思路1：借助插入元素的思路，假设起初堆中只包含一个数据（下标为 1 的数据），然后调用插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样就将包含 n 个数据的数组，组织成了堆。<br>(2) 思路2：从后往前处理数据，每个数据从上往下进行堆化（针对下标 1 ~ n/2 的数据进行堆化，在完全二叉树中，下标 n/2+1 ~ n 的数据都是叶子节点）。</p>
<p><strong>10.3</strong> 实现思路<br>类似于堆顶元素的删除，当堆顶元素移除之后，把下标为 n 的元素放到堆顶，然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 n−1 的位置，一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，就完成了排序。</p>
<p><strong>10.4</strong> 时间复杂度<br>建堆的时间复杂度为 O(n)，排序的时间复杂度为 O(nlogn)，因此堆排序整体的时间复杂度为 O(nlogn)。</p>
<p><strong>10.5</strong> 思考：为什么快速排序比堆排序性能好？<br>(1) 快速排序的数据访问是顺序的，局部的；而堆排序的数据访问不是顺序的，是跳着的，对于CPU缓存不友好。<br>(2) 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="1、二分查找"><a href="#1、二分查找" class="headerlink" title="1、二分查找"></a>1、二分查找</h3><p><strong>1.1</strong> 核心思想<br>每次通过与区间的中间元素进行对比，将查找范围缩小一半，直到查到指定元素或区间被缩小为 0。</p>
<p><strong>1.2</strong> 应用场景<br>(1) 数据必须是有序的。<br>(2) 数据存在上下界。<br>(3) 数据存储在顺序表结构中，元素<strong>能够通过下标进行随机访问</strong>。<br>(4) 数据量适中（太小的话时间上相比顺序遍历没有优势，太大的话对于内存要求过高）。</p>
<p><strong>1.3</strong> 变形问题<br>常用于有序集合（从小到大排列）中存在重复元素的场景。<br>注意细节：终止条件、区间上下边界更新方法、返回值选择。<br>(1) 查找第一个<strong>值等于指定值</strong>的元素。<br>思路：查找到给定值的时候，判断当前位置的前一个元素的值是否也为给定值。<br>(2) 查找最后一个<strong>值等于给定值</strong>的元素。<br>思路：与查找第一个符合条件的元素相似，查找到指定值的时候，判断当前位置的后一个元素的值是否也为指定值。<br>(3) 查找第一个<strong>值大于等于给定值</strong>的元素。<br>思路：每当查找到给定值的位置，判断其前一个元素的值是否小于给定值。<br>(4) 查找最后一个<strong>值小于等于给定值</strong>的元素。<br>思路：每当查找到给定值的位置，判断其后一个元素值是否大于给定值。</p>
<p><strong>1.4</strong> 时间复杂度<br>O(logn)。</p>
<p><strong>1.5</strong> 代码模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 假设数组中的元素是升序排列的</span><br><span class="line">int binarySearch(vector&lt;int&gt; numArray, int target) &#123;</span><br><span class="line">    int index = -1;</span><br><span class="line">    </span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = numArray.size() - 1;</span><br><span class="line">    int mid = (left + right) / 2;</span><br><span class="line">    while (left &lt;= right) &#123;</span><br><span class="line">        if (numArray[mid] == target) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            </span><br><span class="line">            break; </span><br><span class="line">        &#125; else if (numArray[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mid = (left + right) / 2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>将任意长度的二进制值串映射为固定长度的二进制值串（哈希值），其映射规则称为哈希算法。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1、从哈希值不能反向推导出原始数据。<br>2、对输入数据非常敏感，即使只改变 1 个 bit，得到的哈希值也会大不相同。<br>3、针对不同的原始数据，哈希值相同的概率要非常小。<br>4、执行要高效，对于较长的文本，也要能够快速计算出哈希值。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、安全加密<br>常见加密算法：MD5、SHA、DES、AES。</p>
<p>2、唯一标识<br>例：在海量的图库中搜索图片，使用图片的一些信息生成唯一标识。</p>
<p>3、数据校验<br>例：针对从网络上下载的文件进行校验。</p>
<p>4、散列函数<br>例：散列表中使用到的散列函数。</p>
<p>5、负载均衡<br>例：实现一个会话粘滞的负载均衡算法。对客户端IP地址或会话ID计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是需要路由的服务器编号，可以把同一个IP过来的所有请求，都路由到同一个后端服务器上。</p>
<p>6、数据分片<br>例：统计“搜索关键词”出现的次数。从搜索记录的日志文件中，依次独处每个搜索关键词，通过哈希算法计算得到哈希值，跟机器数量n取模，得到机器编号，将同一个搜索关键词分配到同一台机器上，最后将所有机器上的结果合并得到所需内容。</p>
<p>7、分布式存储<br>例：使用<strong>一致性哈希算法</strong>，可以在多台缓存机器集群中加入一个新机器时，不需要做大量的数据搬移。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="1、广度优先搜索（BFS）"><a href="#1、广度优先搜索（BFS）" class="headerlink" title="1、广度优先搜索（BFS）"></a>1、广度优先搜索（BFS）</h3><p>假设使用邻接表来存储无向图，V表示顶点的个数，E表示边的个数。</p>
<p><strong>1.1</strong> 核心思想<br>(1) 每个节点都要访问一次，而且仅访问一次。<br>(2) 先查找离起始顶点最近的，然后是次近的，依次往外搜索。</p>
<p><strong>1.2</strong> 实现思路<br>(1) 记录顶点的访问状态，避免重复访问。<br>(2) 用队列存储已被访问的但是相连顶点未被访问的顶点。<br>(3) 用数组来反向存储路径，下标为x的元素的值是第x个顶点的前驱顶点的编号。</p>
<p><strong>1.3</strong> 时间复杂度<br>因在连通图中，E一定大于等于(V-1)，因此时间复杂度可简写为O(E)。</p>
<p><strong>1.4</strong> 空间复杂度<br>用于存储顶点和顶点状态的数组和队列大小不会超过顶点个数，因此空间复杂度为O(V)。</p>
<p><strong>1.5</strong> 代码模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int, int&gt; visited = &#123;&#125;;</span><br><span class="line">int targetValue;</span><br><span class="line"></span><br><span class="line">void bfs(Node *root) &#123;</span><br><span class="line">    // 终止条件</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue&lt;Node *&gt; nodeQueue;</span><br><span class="line">    nodeQueue.push(root);</span><br><span class="line">    </span><br><span class="line">    while (!nodeQueue.empty()) &#123;</span><br><span class="line">        // 使用队列来保存节点</span><br><span class="line">        Node *node = nodeQueue.front();</span><br><span class="line">        nodeQueue.pop();</span><br><span class="line">        </span><br><span class="line">        // 判断节点是否已访问</span><br><span class="line">        if (visited.count(node-&gt;val)) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[node-&gt;val] = 1;</span><br><span class="line">        </span><br><span class="line">        // 处理当前节点</span><br><span class="line">        if (node-&gt;val == targetValue) &#123;</span><br><span class="line">            // code</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 将当前节点的孩子节点加入队列</span><br><span class="line">        for (int i = 0; i &lt; node-&gt;childrenArray.size(); i++) &#123;</span><br><span class="line">            nodeQueue.push(node-&gt;childrenArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、深度优先搜索（DFS）"><a href="#2、深度优先搜索（DFS）" class="headerlink" title="2、深度优先搜索（DFS）"></a>2、深度优先搜索（DFS）</h3><p>假设使用邻接表来存储无向图，V表示顶点的个数，E表示边的个数。</p>
<p><strong>2.1</strong> 核心思想<br>(1) 每个节点都要访问一次，而且仅访问一次。<br>(2) 从起始顶点开始，遍历各个分支进行查找，没有结果时返回上一个顶点走其他分支。</p>
<p><strong>2.2</strong> 实现思路<br>(1) 使用递归思路进行实现。<br>(2) 记录顶点的访问状态，避免重复访问。<br>(3) 用数组来反向存储路径，下标为x的元素的值是第x个顶点的前驱顶点的编号。</p>
<p><strong>2.3</strong> 时间复杂度<br>每条边最多会被访问2次，因此时间复杂度为O(E)。</p>
<p><strong>2.4</strong> 空间复杂度<br>递归调用栈的最大深度不会超过顶点的个数，因此空间复杂度为O(V)。</p>
<p><strong>2.5</strong> 代码模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int, int&gt; visited = &#123;&#125;;</span><br><span class="line">int targetValue;</span><br><span class="line"></span><br><span class="line">void dfs(Node *root) &#123;</span><br><span class="line">    // 终止条件</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 判断节点是否已访问</span><br><span class="line">    if (visited.count(root-&gt;val)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[root-&gt;val] = 1;</span><br><span class="line">    </span><br><span class="line">    // 处理当前节点</span><br><span class="line">    if (root-&gt;val == targetValue) &#123;</span><br><span class="line">        // code</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 进行不同分支节点的遍历</span><br><span class="line">    for (int i = 0; i &lt; root-&gt;childrenArray.size(); i++) &#123;</span><br><span class="line">        dfs(root-&gt;children[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、双向-BFS"><a href="#3、双向-BFS" class="headerlink" title="3、双向 BFS"></a>3、双向 BFS</h3><p><strong>3.1</strong> 核心思想<br>从<strong>头部</strong>和<strong>尾部</strong>交替（不严格）向中间进行广度优先搜索，直到找到目标为止。</p>
<p><strong>3.2</strong> 代码模板<br>暂无，待补充。</p>
<h3 id="4、启发式搜索"><a href="#4、启发式搜索" class="headerlink" title="4、启发式搜索"></a>4、启发式搜索</h3><p><strong>4.1</strong> 核心思想<br>通过<strong>估价函数</strong>，每次遍历时根据<strong>优先级</strong>找到最有可能的节点，然后进行搜索，直到找到目标为止。</p>
<p><strong>4.2</strong> 代码模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    bool operator&lt; (const Node &amp;A) &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void generate_related_nodes(Node &amp;node) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void process(Node &amp;node) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AstarSearch(vector&lt;vector&lt;int&gt;&gt;&amp; graph, Node&amp; start, Node&amp; end) &#123;</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; visited(graph.size(), vector&lt;bool&gt;(graph[0].size(), false));</span><br><span class="line">    priority_queue&lt;Node&gt; q;</span><br><span class="line">    q.push(start);</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        Node cur = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        visited[cur.x][cur.y] = true;</span><br><span class="line">        </span><br><span class="line">        process(node);</span><br><span class="line">        </span><br><span class="line">        vector&lt;Node&gt; nodes = generate_related_nodes(node);</span><br><span class="line">        </span><br><span class="line">        for (auto node : nodes) &#123;</span><br><span class="line">            if (!visited[node.x][node.y]) &#123;</span><br><span class="line">                q.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><p>场景：在字符串 A 中查找字符串 B。<br>主串：字符串 A，长度为 n。<br>模式串：字符串 B，长度为 m。</p>
<h3 id="1、BF算法"><a href="#1、BF算法" class="headerlink" title="1、BF算法"></a>1、BF算法</h3><p>BF：Brute Force，暴力匹配算法，也可称朴素匹配算法。</p>
<p><strong>1.1</strong> 核心思想<br>在主串中，检查起始位置分别为 0、1、2…(n-m) 且长度为 m 的 n-m+1 个子串，看是否有跟模式串匹配的字符串。</p>
<p><strong>1.2</strong> 时间复杂度<br>每次要对比 m 个字符，总共对比 n-m+1 次，所以整体的时间复杂度为 O(n*m)。</p>
<h3 id="2、RK算法"><a href="#2、RK算法" class="headerlink" title="2、RK算法"></a>2、RK算法</h3><p>RK：Rabin-Karp，由两位发明者的命名而来。</p>
<p><strong>2.1</strong> 核心思想<br>使用哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值进行对比，若哈希值相同，则说明匹配了。</p>
<p><strong>2.2</strong> 哈希算法设计思路<br>假设字符集只包含 K 个字符。<br>(1) 用一个 K 进制数来表示一个子串，将 K 进制数转换成 10 进制数，作为子串的哈希值，这样的算法不会出现哈希值冲突。<br>(2) 该种哈希算法有个特点：相邻子串的哈希值的计算公式有一定关系，可以通过前一个子串的哈希值快速算出下一个子串的哈希值。<br>(3) 为了哈希值能落在整数范围内，可以允许哈希冲突，在冲突时，逐字符比较一下子串和模式串即可，整体的效率还是会比BF算法高。</p>
<p><strong>2.3</strong> 时间复杂度<br>计算子串哈希值的时间复杂度为 O(n)，匹配时哈希值对比的时间复杂度为 O(1)，总共匹配 n-m+1 次，所以整体的时间复杂度为 O(n)。</p>
<h3 id="3、BM算法"><a href="#3、BM算法" class="headerlink" title="3、BM算法"></a>3、BM算法</h3><p>BM：Boyer-Moore。</p>
<p><strong>3.1</strong> 核心思想<br>寻找模式串在主串中移动的规律，减少不必要的字符比较，提升模式串匹配的效率。</p>
<p><strong>3.2</strong> 实现思路<br>“坏字符规则”和好前缀规则“结合使用。<br>(1) 坏字符规则：<br>当发生不匹配的时候，我们把坏字符对应的模式串中的字符的下标记作 si，坏字符在模式串中的下标记作 xi。如果坏字符在模式串中存在，xi 就是坏字符在模式串中的下标，通常取模式串中最后一个坏字符的下标；如果不存在，xi 记作 -1。模式串往后移动的位数就等于 si-xi。<br>(2) 好后缀规则：<br>假设主串中有个子串与模式串末尾的子串匹配，记为 {u}。<br>a) 若在模式串中找到了另一个与 {u} 匹配的子串 {u1}，则将模式串移动到 {u1} 与 {u} 对齐的位置。<br>b) 若在模式串的其他位置找不到与 {u} 匹配的子串，则判断 {u} 的后缀中是否有与模式串的前缀匹配的子串；若存在，则将模式串移动到前缀子串与 {u} 的后缀子串匹配的位置；若不存在，将模式串移动到 {u} 的后面。<br>(3) 规则的使用<br>a) 分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数，可以有效避免坏字符规则时可能出现的移动位数为负数的情况。<br>b) 坏字符规则比较消耗内存，可以只使用好后缀规则。</p>
<p><strong>3.3</strong> 应用场景<br>适合模式串较短的场景（比如文本编辑器中的字符串搜索）。</p>
<h3 id="4、KMP算法"><a href="#4、KMP算法" class="headerlink" title="4、KMP算法"></a>4、KMP算法</h3><p>KMP：Knuth Morris Pratt，由三位作者的命名而来。</p>
<p><strong>4.1</strong> 核心思想<br>寻找模式串在主串中移动的规律，减少不必要的字符比较，提升模式串匹配的效率（相比于BM算法，移动时只关注模式串前缀子串与主串的匹配）。</p>
<p><strong>4.2</strong> 实现思路<br>(1) 每次匹配失败后模式串向后移动的距离仅与<strong>模式串本身</strong>有关。因为当匹配到失败字符时，模式串当前字符之前的子串<strong>肯定与主串中的子串相同</strong>。因此要先找到模式串中出错字符前的子串中的最长可匹配的前缀字符串和后缀字符串，这 2 个字符串的距离之差，就是模式串要移动的距离。<br>(2) 使用 next 数组，下标是模式串中每个前缀字符串的结尾字符的下标，值是该下标对应前缀字符串中的最长可匹配前缀字符串结尾字符的下标，使用下标 -1 表示不存在的情况。</p>
<p><strong>4.3</strong> next数组的构造原理<br>待研究。</p>
<p><strong>4.4</strong> 应用场景<br>似乎适合所有单个字符串匹配的场景？待研究。</p>
<h3 id="5、Trie树"><a href="#5、Trie树" class="headerlink" title="5、Trie树"></a>5、Trie树</h3><p><strong>5.1</strong> 概念<br>trie 树是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。其本质是利用字符串之间的公共前缀，降低查找时间。<br>(1) 节点本身不存储完整单词。<br>(2) 从根节点到某一节点，路径上经过的字符连接起来，就是该节点对应的字符串。<br>(3) 所有节点的子节点路径代表的字符都不相同。</p>
<p><strong>5.2</strong> 存储方式<br>(1) 假设字符串中只有从 a 到 z 这 26 个小写字母，每个节点的数据结构中维护一个当前节点的字符数据和一个大小为 26 的数组。在数组中下标为 0 的位置，存储指向子节点 a 的指针，下标为 1 的位置存储指向子节点 b 的指针，以此类推，下标为 25 的位置，存储的是指向的子节点 z 的指针。如果某个字符的子节点不存在，就在对应的下标的位置存储 NULL。<br>(2) 默认情况下使用的数组会很浪费内存空间，可以替换成散列表、跳表、红黑树等数据结构。</p>
<p><strong>5.3</strong> 时间复杂度<br>(1) 构建 Trie 树：需要遍历所有字符串，因此时间复杂度与构建时用的所有字符串总长度 n 有关，为 O(n)。<br>(2) 查找字符串：字符串长度为 k，最多对比 k 个节点即可得出结果，因此时间复杂度为 O(k)。</p>
<p><strong>5.4</strong> 应用场景<br>适合查找前缀匹配的字符串（比如输入关键词跳出联想结果、对输入内容进行自动补全或修正）。</p>
<h3 id="6、AC自动机"><a href="#6、AC自动机" class="headerlink" title="6、AC自动机"></a>6、AC自动机</h3><p>AC：Aho-Corasick。</p>
<p><strong>6.1</strong> 核心思想<br>在 Trie 树之上，加了类似 KMP 算法的 next 数组，此处的 next 数组是构建在树上的。</p>
<p><strong>6.2</strong> 实现思路<br>(1) 在树的每个节点保存失败指针，对应到 KMP 算法中 next 数组的值。<br>(2) 失败指针的构造与 KMP 算法中 next 数组的构造原理类似。</p>
<p><strong>6.3</strong> 应用场景<br>适合在大量文本中进行多个模式串的匹配查找。</p>
<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，解决这些子问题，然后再合并其结果，通常使用<strong>递归</strong>进行实现。</p>
<h3 id="实战分析"><a href="#实战分析" class="headerlink" title="实战分析"></a>实战分析</h3><p>1、归并排序、快速排序。<br>2、二维平面上有 n 个点，如何快速计算出两个距离最近的点对？<br>3、有两个 n*n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=A*B？<br>4、MapReduce模型。</p>
<h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;auto&gt; DivideAndConquer(auto problem, auto param1, auto param2, ...) &#123;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (problem == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 当前层的处理逻辑</span><br><span class="line">    auto data = PrepareData(problem);</span><br><span class="line">    auto subProblems = SplitProblem(problem, data);</span><br><span class="line">    </span><br><span class="line">    // 进行递归调用</span><br><span class="line">    vector&lt;auto&gt; subResult1 = DivideAndConquer(subProblems[0], p1, p2, ...);</span><br><span class="line">    vector&lt;auto&gt; subResult2 = DivideAndConquer(subProblems[1], p1, p2, ...);</span><br><span class="line">    vector&lt;auto&gt; subResult3 = DivideAndConquer(subProblems[2], p1, p2, ...);</span><br><span class="line">    </span><br><span class="line">    // 合并所有结果</span><br><span class="line">    auto result = MergeResult(subResult1, subResult2, subResult3, ...);</span><br><span class="line">    </span><br><span class="line">    // 清理当前层状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h3 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h3><p>把问题求解的过程分为多个阶段，面对分支时先随意走一个分支，当发现分支走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一个分支继续走，使用<strong>递归</strong>进行实现。</p>
<h3 id="实战分析-1"><a href="#实战分析-1" class="headerlink" title="实战分析"></a>实战分析</h3><p>1、八皇后问题：有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。<br>2、0-1 背包问题。<br>3、正则表达式与文本的匹配。</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h3><p>1、问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。<br>2、在每一步选择中都采取当前状态下的最优解，从而希望实现全局最优。<br>3、与动态规划的不同点在于，贪心算法对于每个子问题的解决方案都做出选择，不能回退；而动态规划会保存以前的运算结果，并根据以前的结果对当前进行选择，可以回退。</p>
<h3 id="实战分析-2"><a href="#实战分析-2" class="headerlink" title="实战分析"></a>实战分析</h3><p>1、分糖果：现在有 m 个糖果和 n 个孩子，要把糖果分给这些孩子吃，但是糖果少，孩子多（m&lt;n），所以糖果只能分配给一部分孩子。如何分配糖果，能尽可能满足最多数量的孩子？<br>2、凑钱：现在有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。现在要用这些钱来支付 K 元，最少要用多少张纸币？<br>3、区间覆盖：现在有 n 个区间，区间的起始端点和结束端点分别是 [l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间？</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划 = 分治 + 最优子结构</p>
<h3 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h3><p><strong>一个模型</strong><br>多阶段决策最优解模型。解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p>
<p><strong>三个特征</strong><br>(1) 最优子结构：问题的最优解包含了子问题的最优解，反之，可以通过子问题的最优解推导出问题的最优解；中途可以淘汰次优解。<br>(2) 无后效性：在推导后面阶段的状态的时候，只关心前面阶段的状态值，无需关心前面状态是如何推导而来的；前一阶段的状态不受后面阶段的决策影响。<br>(3) 重复子问题：不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>1、状态转移表法：状态表通常为二维数组；按照决策过程，通过不断状态递推演进，将状态表填好，再将填表的过程翻译成代码。<br>2、状态转移方程法：根据最优子结构，写出递归公式，再翻译成代码。</p>
<h3 id="编程技巧"><a href="#编程技巧" class="headerlink" title="编程技巧"></a>编程技巧</h3><p>1、寻找问题的重复性（打破自己的思维惯性，形成机器思维）。<br>2、定义状态（理解复杂逻辑的关键）。<br>3、列出 DP 方程。</p>
<h3 id="代码模板-2"><a href="#代码模板-2" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 定义状态（假设是二维的）</span><br><span class="line">dp[][];</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">    for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">        // 状态转移方程</span><br><span class="line">        dp[i][j] = _Function(dp[i&apos;][j&apos;]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回反映最终情况的结果</span><br><span class="line">return dp[m&apos;][n&apos;];</span><br></pre></td></tr></table></figure>
            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    
    <a class="pull-right" href="/2021/01/02/数据结构/">
        数据结构 →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By Viva. All Rights Reserved.
                </p>
                <a href="http://www.beian.miit.gov.cn" style="color: #767D84">浙ICP备20020134号</a>
                <!-- <p>Theme By <a href="//go.kieran.top" style="color: #767D84">Kieran</a></p> -->
            </div>
            <div class="social">
                <ul>
                    
                    
                    
                    
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
